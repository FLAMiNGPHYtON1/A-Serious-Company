const express = require('express');
const multer = require('multer');
const mysql = require('mysql2');
const cors = require('cors');
const path = require('path');
const fs = require('fs');

const app = express();
app.use(cors());
app.use(express.json()); // Parse JSON requests

// MySQL configuration
const dbConfig = {
    host: 'localhost',
    user: 'root',
    password: '123123123',
};

// Create a MySQL connection
const connection = mysql.createConnection(dbConfig);

// Function to initialize the database
function initializeDatabase() {
    connection.connect((err) => {
        if (err) throw err;
        console.log('Connected to MySQL server.');

        // Check if the database exists
        connection.query("SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = 'file_management'", (err, results) => {
            if (err) throw err;

            if (results.length === 0) {
                // If the database does not exist, create it
                connection.query('CREATE DATABASE file_management', (err) => {
                    if (err) throw err;
                    console.log("Database 'file_management' created successfully.");
                });
            } else {
                console.log("Database 'file_management' already exists.");
            }

            // Use the database
            connection.query('USE file_management', (err) => {
                if (err) throw err;
                console.log("Switched to database 'file_management'.");

                // Proceed to set up the tables
                createDatabaseConnection();
            });
        });
    });
}

// Function to create a connection to the file_management database
function createDatabaseConnection() {
    // Read the setup script and execute it
    const setupScript = fs.readFileSync(path.join(__dirname, 'setup.sql'), 'utf8');
    const sqlStatements = setupScript.split(';').map(statement => statement.trim()).filter(Boolean); // Split by semicolon and filter empty statements

    // Execute each SQL statement one by one
    let index = 0;

    function executeNext() {
        if (index < sqlStatements.length) {
            const statement = sqlStatements[index];
            connection.query(statement, (err) => {
                if (err) {
                    console.error('Error executing statement:', statement);
                    throw err; // Handle error
                }
                index++;
                executeNext(); // Execute the next statement
            });
        } else {
            console.log("Database tables checked/created successfully.");
            // No need to end the connection here as it's being used for further operations
        }
    }

    executeNext(); // Start executing statements
}

// Call the database initialization function
initializeDatabase();

// Configure Multer
const storage = multer.diskStorage({
    destination: './uploads/',
    filename: (req, file, cb) => {
        const uniqueName = Date.now() + path.extname(file.originalname);
        cb(null, uniqueName);
    },
});
const upload = multer({ storage });

// 1. POST /upload - Upload a New File
app.post('/upload', upload.single('file'), (req, res) => {
    const originalFilename = req.file.originalname; // Get original filename
    let filename = req.file.filename; // Use the unique name generated by multer
    const filepath = req.file.path;
    const fileSize = req.file.size; // Get the file size

    // Check for duplicates
    const checkForDuplicates = (originalFilename) => {
        return new Promise((resolve, reject) => {
            const sql = 'SELECT * FROM files WHERE filename = ?';
            connection.query(sql, [originalFilename], (err, results) => {
                if (err) return reject(err);
                resolve(results.length > 0); // Returns true if a duplicate exists
            });
        });
    };

    const generateUniqueFilename = async (baseName, extension) => {
        let counter = 1;
        let newFilename = baseName + extension;

        while (await checkForDuplicates(newFilename)) {
            newFilename = `${baseName} (${counter++})${extension}`; // Append integer to filename
        }

        return newFilename;
    };

    const fileExtension = path.extname(originalFilename); // Get the original file extension
    const baseName = path.basename(originalFilename, fileExtension); // Get the base name without extension

    generateUniqueFilename(baseName, fileExtension).then(uniqueFilename => {
        // Insert into the database with the unique filename and file size
        const sql = 'INSERT INTO files (filename, path, FileSize) VALUES (?, ?, ?)';
        connection.query(sql, [uniqueFilename, filepath, fileSize], (err, result) => {
            if (err) return res.status(500).json({ error: err.message });
            res.status(201).json({ 
                message: 'File uploaded successfully!', 
                file: { id: result.insertId, filename: uniqueFilename, size: fileSize } 
            });
        });
    }).catch(err => {
        console.error('Error checking for duplicates:', err);
        res.status(500).json({ error: 'Internal server error.' });
    });
});

// 2. GET /files - Retrieve All Files
app.get('/files', (req, res) => {
    const sql = 'SELECT * FROM files';
    connection.query(sql, (err, results) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(results);
    });
});

// 3. DELETE /files/:id - Delete a File by ID
app.delete('/files/:id', (req, res) => {
    const fileId = req.params.id;
    const sql = 'SELECT * FROM files WHERE id = ?';
    connection.query(sql, [fileId], (err, results) => {
        if (err) return res.status(500).json({ error: err.message });
        if (results.length === 0) return res.status(404).json({ error: 'File not found.' });

        const filepath = path.join(__dirname, results[0].path); // Absolute path to the file
        // Delete the file from the filesystem
        fs.unlink(filepath, (err) => {
            if (err) return res.status(500).json({ error: 'Failed to delete YOUR file.' });

            // Delete the file record from the database
            const deleteSql = 'DELETE FROM files WHERE id = ?';
            connection.query(deleteSql, [fileId], (err) => {
                if (err) return res.status(500).json({ error: err.message });
                res.json({ message: 'File deleted successfully!' });
            });
        });
    });
});

// 4. PUT /files/:id - Update the File Name
app.put('/files/:id', (req, res) => {
    const fileId = req.params.id;
    const newFilename = req.body.filename;

    const sql = 'UPDATE files SET filename = ? WHERE id = ?';
    connection.query(sql, [newFilename, fileId], (err) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ message: 'File name updated successfully!' });
    });
});

// 5. GET /download/:id - Download a File by ID
app.get('/download/:id', (req, res) => {
    const fileId = req.params.id;

    const sql = 'SELECT * FROM files WHERE id = ?';
    connection.query(sql, [fileId], (err, results) => {
        if (err) return res.status(500).json({ error: 'Internal Server Error' });
        if (results.length === 0) return res.status(404).json({ error: 'File not found.' });

        const filepath = results[0].path; // Get the file path from the database
        const originalFilename = results[0].filename; // Get the original filename
        const fileType = getMimeType(originalFilename); // Get MIME type based on the filename

        res.setHeader('Content-Type', fileType);
        res.download(filepath, originalFilename, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
                res.status(500).json({ error: 'Error downloading the file.' });
            }
        });
    });
});

function getMimeType(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    switch (ext) {
        case 'jpg':
        case 'jpeg':
            return 'image/jpeg';
        case 'png':
            return 'image/png';
        case 'gif':
            return 'image/gif';
        case 'pdf':
            return 'application/pdf';
        case 'doc':
        case 'docx':
            return 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
        case 'txt':
            return 'text/plain';
        case 'mp3':
            return 'audio/mpeg';
        case 'wav':
            return 'audio/wav';
        case 'zip':
            return 'application/zip';
        default:
            return 'application/octet-stream'; // Fallback for unknown types
    }
}

const PORT = 5000;
app.listen(PORT, () => console.log(`Server running on http://localhost:${PORT}`));
